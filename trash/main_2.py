import pygamefrom pygame.locals import *import pygame_guiimport sysimport astimport randomfrom collections import dequepygame.init()pygame.mixer.init()pygame.font.init()pygame.display.set_caption('pycMAN')window_surface = pygame.display.set_mode((800, 600))clock = pygame.time.Clock()background = pygame.Surface((800, 600))background.fill(pygame.Color('#000000'))manager = pygame_gui.UIManager((800, 600))brash_button_x = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((525, 125), (50, 50)),                                             text='x',                                             manager=manager)# Углыbrash_button_lu = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((525, 175), (50, 50)),                                             text='лв',                                             manager=manager)brash_button_ru = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((575, 175), (50, 50)),                                             text='пв',                                             manager=manager)brash_button_ld = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((525, 225), (50, 50)),                                             text='лн',                                             manager=manager)brash_button_rd = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((575, 225), (50, 50)),                                             text='пн',                                             manager=manager)# стеныbrash_button_u = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((625, 175), (50, 50)),                                             text='в',                                             manager=manager)brash_button_d = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((675, 175), (50, 50)),                                             text='н',                                             manager=manager)brash_button_l = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((625, 225), (50, 50)),                                             text='л',                                             manager=manager)brash_button_r = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((675, 225), (50, 50)),                                             text='п',                                             manager=manager)# Остольныеstart_button = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((525, 275), (200, 50)),                                             text='Зпустить игру',                                             manager=manager)exit_button = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((525, 325), (200, 50)),                                             text='Выход',                                             manager=manager)save_button = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((525, 375), (200, 50)),                                             text='Сохранить карту',                                             manager=manager)load_button = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((525, 425), (200, 50)),                                             text='Загрузить карту',                                             manager=manager)load_eats = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((525, 475), (200, 50)),                                             text='Загрузить еду',                                             manager=manager)clock = pygame.time.Clock()is_running = TrueBLACK = (0,0,0)RED = (255, 0, 0)YELLOW = (255, 255, 0)PURPUR = (249,5,254)GREY = (33,33,33)GREEN = (0, 252, 76)BLUE = (0, 255, 255)ORENGE = (255, 185, 81)PINKY = (255,185,255)eats_count = 0f1 = pygame.font.Font(None, 36)cols, rows = 28, 36TILE = 15margin = 0# Создаем поле игрыgame_fild = [ ['0' for r in range(28)] for r in range(36) ]#print(game_fild)# Грузим картинкиfloor1 = pygame.image.load('assets/floor_1.png').convert_alpha()floor2 = pygame.image.load('assets/floor_2.png').convert_alpha()coin1 = pygame.image.load('assets/coin_1.png').convert_alpha()coin2 = pygame.image.load('assets/coin_2.png').convert_alpha()coin3 = pygame.image.load('assets/coin_3.png').convert_alpha()# стеныwall_up = pygame.image.load('assets/wall_U.png').convert_alpha()wall_down = pygame.image.load('assets/wall_D.png').convert_alpha()wall_left = pygame.image.load('assets/wall_L.png').convert_alpha()wall_right = pygame.image.load('assets/wall_R.png').convert_alpha()# углыwall_up_r = pygame.image.load('assets/wall_R_U.png').convert_alpha()wall_up_l = pygame.image.load('assets/wall_L_U.png').convert_alpha()wall_down_r = pygame.image.load('assets/wall_R_D.png').convert_alpha()wall_down_l = pygame.image.load('assets/wall_L_D.png').convert_alpha()flame = pygame.image.load('assets/flame.png').convert_alpha()class DrawMap(pygame.sprite.Sprite):    def __init__(self):        pygame.sprite.Sprite.__init__(self)        self.image = pygame.Surface((420, 540))        #self.image.fill(GREY)        self.rect = self.image.get_rect()        self.rect.x = margin #x        self.rect.y = margin #y        self.positiv = '⌝'        self.negativ = '1'    def update(self):        bg = pygame.Rect(0, 0, 420, 540)        pygame.draw.rect(self.image, BLACK, bg)        # Редактор карты        keystate = pygame.mouse.get_pressed()        pos = pygame.mouse.get_pos()                    if pos[0] <= 450 and pos[1] <= 570:            if keystate[0]:                                  x_cord = round((pos[1]-8)/15)                  y_cord = round((pos[0]-8)/15)                print(x_cord,y_cord)                if game_fild[x_cord][y_cord] == game_fild[x_cord][y_cord]:                    game_fild[x_cord][y_cord] = self.positiv                elif game_fild[x_cord][y_cord] == self.positiv:                    game_fild[x_cord][y_cord] = self.negativ                # Рисуем сетку        for row in range(len(game_fild)):            for col in range(len(game_fild[row])):                             textur = floor1                rect = pygame.Rect(col*TILE, row*TILE, TILE, TILE)                #rect = pygame.Rect(col*15, row*15, 5, 5)                border_color = GREY                # Рендер пола                image_out = pygame.transform.scale(floor1, (15,15))                self.image.blit(image_out, (col*TILE, row*TILE))                # рендер стен                if game_fild[row][col] == '1':                                        textur = wall_up                # стены                                if game_fild[row][col] == '-':                                        textur = wall_up                if game_fild[row][col] == '_':                                        textur = wall_down                if game_fild[row][col] == '⌋':                                        textur = wall_right                if game_fild[row][col] == '⌊':                                        textur = wall_left                # Углы                if game_fild[row][col] == '⌝':                                        textur = wall_up_r                if game_fild[row][col] == '⌜':                                        textur = wall_up_l                if game_fild[row][col] == '⌞':                                        textur = wall_down_l                if game_fild[row][col] == '⌟':                                        textur = wall_down_r                image_out = pygame.transform.scale(textur, (15,15))                self.image.blit(image_out, (col*TILE, row*TILE))                # Рендер предметов                # if game_fild[row][col] == 'e':                #     #pygame.draw.rect(self.image, YELLOW, rect)                #     pygame.draw.circle(self.image, YELLOW, (col*TILE+TILE/2, row*TILE+TILE/2), 7)    def DrawBFS(self,queue,visited,goal,start,graph):        #print("работа алгоритма")        #рисуем путь работы алгоритма        # queue , visited = ghost.logic3()        path_head,path_segment = goal,goal        while path_segment and path_segment in visited:            pygame.draw.rect(self.image, pygame.Color('white'), get_rect(*path_segment), border_radius=TILE//3)            path_segment = visited[path_segment]        pygame.draw.rect(self.image, pygame.Color('blue'), get_rect(*start), border_radius=TILE//3)        pygame.draw.rect(self.image, pygame.Color('magenta'), get_rect(*path_head), border_radius=TILE//3)class Pycman(pygame.sprite.Sprite):    def __init__(self):        pygame.sprite.Sprite.__init__(self)        self.x = 0        self.y = 0        # self.x_start_pos = 240        # self.y_start_pos = 480        self.x_start_pos = 15*14+7        self.y_start_pos = 15*30+margin        self.image = pygame.Surface((15, 15))        #self.image.fill(BLACK)        self.rect = self.image.get_rect()        self.rect.centerx = self.x_start_pos #x        self.rect.bottom = self.y_start_pos #y        self.speed = 15        self.speed_x = 0        self.speed_y = 0    def update(self):         global eats_count               # кординаты и сенсоры        y = int(self.rect.y/15-margin)+28        x = int(self.rect.x/15-margin)+28        y_real = self.rect.y/15-margin        x_real = self.rect.x/15-margin        #print(str(x)+' '+str(y))        cords = game_fild[y][x]                       sensor_left = game_fild[y][x-1]        sensor_top = game_fild[y-1][x]        try: # обрабатываем ощибку отсутствия элемента массива            sensor_right = game_fild[y][x+1]            sensor_bottom = game_fild[y+1][x]        except:            print('ошибка')            sensor_right = '0'                        sensor_bottom = '0'                # Кнопки упровления        keystate = pygame.key.get_pressed()        if keystate[pygame.K_LEFT] and sensor_left != '1' and x_real.is_integer():                 self.speed_x = -self.speed            self.speed_y = 0        if keystate[pygame.K_RIGHT] and sensor_right != '1' and x_real.is_integer():            self.speed_x = self.speed            self.speed_y = 0        if keystate[pygame.K_UP] and sensor_top != '1' and y_real.is_integer():              self.speed_y = -self.speed            self.speed_x = 0        if keystate[pygame.K_DOWN] and sensor_bottom != '1' and y_real.is_integer():                        self.speed_y = self.speed            self.speed_x = 0        # столкновения со стенами        if sensor_left == '1' and self.speed_x < 0 :            self.speed_x = 0        if sensor_right == '1' and self.speed_x > 0 :                        self.speed_x = 0        if sensor_top == '1' and self.speed_y < 0 :            self.speed_y = 0                    if sensor_bottom == '1' and self.speed_y > 0 :                        self.speed_y = 0           # Кушаем еду на карте        if cords == 'e':            #print('work')            game_fild[y][x] = '0'            eats_count += 1              # движение        self.rect.x += self.speed_x            self.rect.y += self.speed_y        # столкновение с краями карты        if self.rect.right > 15*28+margin:            self.rect.left = margin        if self.rect.left < margin:            self.rect.left = 15*27+margin        if self.rect.bottom > 15*36+margin:            self.rect.top = margin        if self.rect.top < margin:            self.rect.top = 15*35+margin            	# Рисуем персонажа        rect = pygame.Rect(4, 0, 15, 15)        fill_color = YELLOW        pygame.draw.circle(self.image, fill_color, (7,7), 7)class Pycman2(pygame.sprite.Sprite):    def __init__(self):        pygame.sprite.Sprite.__init__(self)        self.image = pygame.Surface((45, 45))        #self.image.fill(BLACK)        self.image.set_alpha(200)        self.rect = self.image.get_rect()        cords = get_cord(0,0)        self.rect.x = cords[0] #x        self.rect.y = cords[0] #y        self.speed = 15        self.speed_x = 0        self.speed_y = 0    def update(self):        comands = []        x,y = get_my_rect(self.rect.x,self.rect.y)        #print(x,y)        cords = game_fild[int(y)][int(x)]        sensor_left = game_fild[y][x-1]        sensor_top = game_fild[y-1][x]        try: # обрабатываем ощибку отсутствия элемента массива            sensor_right = game_fild[y][x+1]            sensor_bottom = game_fild[y+1][x]        except:            print('ошибка')            sensor_right = '0'                        sensor_bottom = '0'        keystate = pygame.key.get_pressed()        if keystate[pygame.K_LEFT]:            comands.append('left')        if keystate[pygame.K_RIGHT]:            comands.append('right')         if keystate[pygame.K_UP]:            comands.append('top')        if keystate[pygame.K_DOWN]:            comands.append('bottom')                    x_not = (self.rect.x / 15)-margin        y_not = (self.rect.y / 15)-margin                if x_not.is_integer() and y_not.is_integer():            if comands != [] :                                if comands[0] == 'left' and sensor_left != '1':                    self.speed_x = -self.speed                    self.speed_y = 0                if comands[0] == 'right' and sensor_right != '1':                    self.speed_x = self.speed                    self.speed_y = 0                if comands[0] == 'top' and sensor_top != '1':                    self.speed_x = 0                    self.speed_y = -self.speed                if comands[0] == 'bottom' and sensor_bottom != '1':                    self.speed_x = 0                    self.speed_y = self.speed             # столкновения со стенами            if sensor_left == '1' and self.speed_x < 0 :                self.speed_x = 0            if sensor_right == '1' and self.speed_x > 0 :                            self.speed_x = 0            if sensor_top == '1' and self.speed_y < 0 :                self.speed_y = 0                        if sensor_bottom == '1' and self.speed_y > 0 :                            self.speed_y = 0          # столкновение с краями карты        if self.rect.right > 15*28+margin:            self.rect.left = margin        if self.rect.left < margin:            self.rect.left = 15*28                # Кушаем еду на карте        if cords == 'e':                        game_fild[int(y)][int(x)] = '0'            #eats_count += 1                # движение        self.rect.x += self.speed_x            self.rect.y += self.speed_y                  # Рисуем персонажа                fill_color = YELLOW        pygame.draw.circle(self.image, fill_color, (45/2,45/2), 7)            def reset(self):        cords = get_cord(1,1)        self.rect.x = cords[0] #x        self.rect.y = cords[1] #y        self.speed_x = 0        self.speed_y = 0class Ghost(pygame.sprite.Sprite):    def __init__(self):        pygame.sprite.Sprite.__init__(self)        self.x = 0        self.y = 0        self.x_start_pos = 13*15+7        self.y_start_pos = 14*15+margin        self.image = pygame.Surface((15, 15))        #self.image.fill(BLACK)        self.rect = self.image.get_rect()        self.rect.centerx = self.x_start_pos #x        self.rect.bottom = self.y_start_pos #y        self.speed = 15        self.speed_x = 0        self.speed_y = 0        self.my_speed = 0        self.my_speed_predel = 3        self.choice = []        self.direction = ''    def update(self):                # кординаты и сенсоры        # y = int(self.rect.bottom/15-30)+28        # x = int(self.rect.centerx/15-30)+28        y_real = self.rect.bottom/15-margin        x_real = self.rect.centerx/15-margin        # y = int(self.rect.y/15-30)+28        # x = int(self.rect.x/15-30)+28        cords = get_my_rect_2(self.rect.x,self.rect.y)        y = cords[1]        x = cords[0]                cords = game_fild[y][x]                       sensor_left = game_fild[y][x-1]        sensor_top = game_fild[y-1][x]        try: # обрабатываем ощибку отсутствия элемента массива            sensor_right = game_fild[y][x+1]            sensor_bottom = game_fild[y+1][x]        except:            sensor_right = '0'                        sensor_bottom = '0'        sensors = [sensor_left,sensor_top,sensor_right,sensor_bottom]                # Логика        self.direction = self.logic3()        #print(self.direction)        if self.direction == 'left' :            self.speed_x = -self.speed            self.speed_y = 0        if self.direction == 'right' :            self.speed_x = self.speed            self.speed_y = 0        if self.direction == 'top' :            self.speed_x = 0            self.speed_y = -self.speed        if self.direction == 'bottom' :            self.speed_x = 0            self.speed_y = self.speed        #print(self.direction)        # столкновения со стенами        if sensor_left == '1' and self.speed_x < 0:             #print('work1')                       self.speed_x = 0        if sensor_right == '1' and self.speed_x > 0:            #print('work2')            self.speed_x = 0        if sensor_top == '1' and self.speed_y < 0:            #print('work3')            self.speed_y = 0                    if sensor_bottom == '1' and self.speed_y > 0:             #print('work4')                       self.speed_y = 0                   # движение        # if self.my_speed == self.my_speed_predel:        #     self.rect.x += self.speed_x            #     self.rect.y += self.speed_y        #     self.my_speed = 0        # self.my_speed += 1        self.rect.x += self.speed_x            self.rect.y += self.speed_y        # столкновение с краями карты        if self.rect.right > 15*28+margin:            self.rect.left = margin        if self.rect.left < margin:            self.rect.left = 15*27+margin        if self.rect.bottom > 15*36+margin:            self.rect.top = margin        if self.rect.top < margin:            self.rect.top = 15*35+margin                # Рисуем персонажа        #rect = pygame.Rect(0, 0, 15, 15)        fill_color = RED        pygame.draw.circle(self.image, fill_color, (7,7), 7)            # логика поведения    def logic(self,sensors):        sensor_left = sensors[0]        sensor_top = sensors[1]        sensor_right = sensors[2]        sensor_bottom = sensors[3]        # Логика поведения                 if sensor_top != '1' and self.speed_x == 0 and self.speed_y == 0:              self.choice.append('top')        if sensor_left != '1' and self.speed_x == 0 and self.speed_y == 0:                 self.choice.append('left')        if sensor_bottom != '1' and self.speed_x == 0 and self.speed_y == 0:                        self.choice.append('bottom')        if sensor_right != '1' and self.speed_x == 0 and self.speed_y == 0:            self.choice.append('right')        # Следим за пакманом        # print(player.rect.centerx)        # print(player.rect.bottom)        # if player.rect.bottom < self.rect.bottom :          #     self.choice.append('top')        # if player.rect.centerx < self.rect.centerx :             #     self.choice.append('left')        # if player.rect.bottom > self.rect.bottom :                    #     self.choice.append('bottom')        # if player.rect.centerx > self.rect.centerx :        #     self.choice.append('right')        #print(len(self.choice))        if len(self.choice) > 2:            #print(len(self.choice))            index = random.randint(0, len(self.choice)-1)        else:            self.choice.append('top')            index = 0        if self.speed_x == 0 and self.speed_y == 0:            direction = self.choice[index]            self.choice.pop(index)        else:            direction = self.direction                return direction    def logic2(self,sensors):        direction = self.direction        choice = []        sensor_left = sensors[0]        sensor_top = sensors[1]        sensor_right = sensors[2]        sensor_bottom = sensors[3]        if '1' not in sensors:            direction = 'top'        else:            if sensor_top == '0':                choice.append('top')            if sensor_left == '0':                choice.append('left')            if sensor_right == '0':                choice.append('right')            if sensor_bottom == '0':                choice.append('bottom')            index = random.randint(0, len(choice)-1)            direction = choice[index]        return direction    def logic3(self,sensors=None):        # print(player.rect.centerx)        # print(player.rect.bottom)        pacman_pos = get_my_rect(player.rect.x,player.rect.y)        start = get_my_rect_2(self.rect.x,self.rect.y)        graph = get_graf(game_fild)        #print(pacman_pos)        #print(game_fild[pacman_pos[1]][pacman_pos[0]])                #print(start)        visited = ()        queue = []                 try:            if pacman_pos and game_fild[pacman_pos[1]][pacman_pos[0]] != '1':                goal = pacman_pos                queue, visited = bfs(start, pacman_pos, graph)        except:            print('Ошибка')                # рисуем путь работы алгоритма        path_gost = []        path_head,path_segment = goal,goal        while path_segment and path_segment in visited:            path_segment = visited[path_segment]            path_gost.append(path_segment)                #print(get_my_rect(self.rect.x,self.rect.y))        #print(path_gost)        #level.DrawBFS(queue,visited,goal,start,graph)                direction = ' '        if len(path_gost) > 2:            path_gost.pop(-1)            #path_gost.pop(-1)            #path_gost.pop(-1)            # path_gost.pop(-1)            # path_gost.pop(-1)            path_gost.reverse()            #print(path_gost)            if path_gost[1][0]<start[0] and path_gost[1][1] == start[1]:                #print('left')                direction = 'left'            if path_gost[1][0]>start[0] and path_gost[1][1] == start[1]:                #print('right')                direction = 'right'            if path_gost[1][0] == start[0] and path_gost[1][1] < start[1]:                #print('top')                               direction = 'top'            if path_gost[1][0] == start[0] and path_gost[1][1] > start[1]:                #print('bottom')                direction = 'bottom'                return directionclass Ghost2(pygame.sprite.Sprite):    def __init__(self,x,y,color=GREEN,speed=3):        pygame.sprite.Sprite.__init__(self)        self.color = color        self.x = 0        self.y = 0        self.rest_cord = get_cord(x,y)        self.x_start_pos = 13*15+7        self.y_start_pos = 14*15+margin        self.image = pygame.Surface((45, 45))        #self.image.fill(BLACK)        self.image.set_alpha(200)        self.rect = self.image.get_rect()        cords = get_cord(x,y)        self.rect.x = cords[0] #x        self.rect.y = cords[1] #y        self.speed = speed        self.speed_x = 0        self.speed_y = 0         self.choice = []        self.direction = ''    def update(self):         comands = []        x,y = get_my_rect(self.rect.x,self.rect.y)        #print(x,y)        cords = game_fild[int(y)][int(x)]        sensor_left = game_fild[y][x-1]        sensor_top = game_fild[y-1][x]        try: # обрабатываем ощибку отсутствия элемента массива            sensor_right = game_fild[y][x+1]            sensor_bottom = game_fild[y+1][x]        except:            print('ошибка')            sensor_right = '0'                        sensor_bottom = '0'                #print(game_fild[y+1][x])        #print(sensor_right +' right')        #print(sensor_left + ' left')        #print(sensor_top + ' top')        #print(sensor_bottom+ ' bottom')        # Логика        self.direction = self.logic3()        #print(self.direction)        if self.direction == 'left' :            comands.append('left')        if self.direction == 'right' :            comands.append('right')        if self.direction == 'top' :            comands.append('top')        if self.direction == 'bottom' :            comands.append('bottom')                    x_not = (self.rect.x / 15)-margin        y_not = (self.rect.y / 15)-margin                        if x_not.is_integer() and y_not.is_integer():            #print(y-1,x)            if comands != [] :                                if comands[0] == 'left' and sensor_left != '1':                    self.speed_x = -self.speed                    self.speed_y = 0                if comands[0] == 'right' and sensor_right != '1':                    self.speed_x = self.speed                    self.speed_y = 0                if comands[0] == 'top' and sensor_top != '1':                    #print('work2')                    self.speed_x = 0                    self.speed_y = -self.speed                if comands[0] == 'bottom' and sensor_bottom != '1':                    self.speed_x = 0                    self.speed_y = self.speed             # столкновения со стенами            if sensor_left == '1' and self.speed_x < 0 :                #print('work1')                self.speed_x = 0            if sensor_right == '1' and self.speed_x > 0 :                 #print('work1')                           self.speed_x = 0            if sensor_top == '1' and self.speed_y < 0 :                #print('work1')                self.speed_y = 0                        if sensor_bottom == '1' and self.speed_y > 0 :                 #print('work1')                           self.speed_y = 0          # столкновение с краями карты        if self.rect.right > 15*28+margin:            self.rect.left = margin        if self.rect.left < margin:            self.rect.left = 15*28        # движение        self.rect.x += self.speed_x            self.rect.y += self.speed_y            # Рисуем персонажа                fill_color = self.color        pygame.draw.circle(self.image, fill_color, (45/2,45/2), 7)     # логика поведения    def logic3(self,sensors=None):        # print(player.rect.centerx)        # print(player.rect.bottom)        pacman_pos = get_my_rect(player.rect.x,player.rect.y)        start = get_my_rect(self.rect.x,self.rect.y)        graph = get_graf(game_fild)        # print(pacman_pos)        # print(game_fild[pacman_pos[1]][pacman_pos[0]])                # print(start)        visited = ()        queue = []                 try:            if pacman_pos and game_fild[pacman_pos[1]][pacman_pos[0]] != '1':                goal = pacman_pos                queue, visited = bfs(start, pacman_pos, graph)        except:            print('Ошибка')                # рисуем путь работы алгоритма        path_gost = []        path_head,path_segment = goal,goal        while path_segment and path_segment in visited:            path_segment = visited[path_segment]            path_gost.append(path_segment)                #print(get_my_rect(self.rect.x,self.rect.y))        #print(path_gost)        #level.DrawBFS(queue,visited,goal,start,graph)                direction = ' '        if len(path_gost) > 2:            path_gost.pop(-1)            #path_gost.pop(-1)            #path_gost.pop(-1)            # path_gost.pop(-1)            # path_gost.pop(-1)            path_gost.reverse()            #print(path_gost)            if path_gost[1][0]<start[0] and path_gost[1][1] == start[1]:                #print('left')                direction = 'left'            if path_gost[1][0]>start[0] and path_gost[1][1] == start[1]:                #print('right')                direction = 'right'            if path_gost[1][0] == start[0] and path_gost[1][1] < start[1]:                #print('top')                               direction = 'top'            if path_gost[1][0] == start[0] and path_gost[1][1] > start[1]:                #print('bottom')                direction = 'bottom'                return direction    def reset(self):                self.rect.x = self.rest_cord[0] #x        self.rect.y = self.rest_cord[1] #ydef get_my_rect(x,y):    #print((y-30)/TILE)    #print(((y-30)/TILE)-1)    return int((x-margin)/TILE)+1, int((y-margin)/TILE)+1    #return int(x/15-30)+28 , int(y/15-30)+28def get_my_rect_2(x,y):    #print((y-30)/TILE)    #print(((y-30)/TILE)-1)    return int((x-margin)/TILE), int((y-margin)/TILE)def get_rect(x,y):    return x * TILE + 1, y * TILE + 1, TILE - 2, TILE - 2 def get_cord(x,y):    return x * TILE, y * TILEdef get_next_nodes(x, y):    check_next_node = lambda x,y: True if 0 <= x < cols and 0 <= y < rows and game_fild[y][x] != '1' else False    ways = [-1,0], [0,-1], [1,0], [0,1]    return [(x+dx,y+dy) for dx,dy in ways if check_next_node(x+dx,y+dy)]def bfs(start, goal, graph) :    queue = deque ([start])    visited = {start: None}    while queue:                cur_node = queue.popleft()                if cur_node == goal:            break        #print('++++'+str(graph[cur_node]))        next_nodes = graph[cur_node]        for next_node in next_nodes:            if next_node not in visited:                queue.append(next_node)                visited[next_node] = cur_node    return queue, visiteddef get_graf(arr):    # создаем граф из массива поля игры    graph = {}    for y,row in enumerate(arr):        for x, col in enumerate(row):                   if col == '0' or col == 'e' :                           graph[(x,y)] = graph.get((x,y),[]) + get_next_nodes(x,y)    return graph# Основной цыкл игры    def main():      global is_running,game_fild,player,level     play_game = False    with open('game_fild.txt', 'r') as file:        game_fild = ast.literal_eval(file.read())    all_sprites = pygame.sprite.Group()    walls = pygame.sprite.Group()    # Добовляем поле    level = DrawMap()    all_sprites.add(level)    # Добовляем персонажа на поле    # player = Pycman2()    # all_sprites.add(player)    # Добовляем призраков на поле        # ghost = Ghost2(12,14,PINKY)        # all_sprites.add(ghost)        # ghost2 = Ghost2(14,14,BLUE,5)        # all_sprites.add(ghost2)        # ghost3 = Ghost2(13,14,ORENGE)        # all_sprites.add(ghost3)        # ghost4 = Ghost2(13,11,RED)        # all_sprites.add(ghost4)    ghosts = []    # настройки для поиска пути    start = (14,15)    goal = start    queue = deque([start])    visited = {start:None}    cur_node = start              while is_running:        time_delta = clock.tick(10)/500.0                # Обработка событий в игре        for event in pygame.event.get():            if event.type == pygame.QUIT:                is_running = False            if event.type == pygame_gui.UI_BUTTON_PRESSED:                if event.ui_element == start_button:                    print('Hello World!')                    play_game=True                if event.ui_element == exit_button:                    print('Good bay!')                    pygame.quit()                    sys.exit()                if event.ui_element == save_button:                    #print(game_fild)                    with open('game_fild.txt', 'w') as file:                        file.write(str(game_fild))                if event.ui_element == load_button:                    #print('123')                    with open('game_fild.txt', 'r') as file:                        game_fild = ast.literal_eval(file.read())                    #print(game_fild)                if event.ui_element == load_eats:                    for row in range(len(game_fild)):                        for col in range(len(game_fild[row])):                             if game_fild[row][col] == '0':                                game_fild[row][col] = 'e'                # редактор                if event.ui_element == brash_button_x:                    level.positiv = '0'                    level.negativ = '1'                # Углы                if event.ui_element == brash_button_lu:                    level.positiv = '⌜'                    level.negativ = '1'                if event.ui_element == brash_button_ru:                    level.positiv = '⌝'                    level.negativ = '1'                if event.ui_element == brash_button_ld:                    level.positiv = '⌞'                    level.negativ = '1'                if event.ui_element == brash_button_rd:                    level.positiv = '⌟'                    level.negativ = '1'                # Стены                if event.ui_element == brash_button_u:                    level.positiv = '-'                    level.negativ = '1'                if event.ui_element == brash_button_d:                    level.positiv = '_'                    level.negativ = '1'                if event.ui_element == brash_button_l:                    level.positiv = '⌋'                    level.negativ = '1'                if event.ui_element == brash_button_r:                    level.positiv = '⌊'                    level.negativ = '1'                            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_ESCAPE:                    play_game=False            manager.process_events(event)                  for ghost in ghosts:             if player.rect.colliderect(ghost):                print('Стоп игра')                with open('game_fild.txt', 'r') as file:                        game_fild = ast.literal_eval(file.read())                player.reset()                for r_ghost in ghosts:                    r_ghost.reset()            # Обновление        all_sprites.update()        window_surface.blit(background, (0, 0))                # рисуем работу алгоритма        [pygame.draw.rect(window_surface, pygame.Color('forestgreen'),get_rect(x,y)) for x,y in visited]        [pygame.draw.rect(window_surface, pygame.Color('darkslategray'),get_rect(x,y)) for x,y in queue]        # bfs, get path to mouse click        # mouse_pos = get_click_mouse_pos()        # if mouse_pos and not grid[mouse_pos[1]][mouse_pos[0]]:        #     queue, visited = bfs(start, mouse_pos, graph)        #     goal = mouse_pos                # # Рисуем сетку        # for row in range(len(game_fild)):        # 	for col in range(len(game_fild[row])):        # 		rect = pygame.Rect(30+col*15, 30+row*15, 15, 15)        # 		border_color = GREY        # 		pygame.draw.rect(window_surface, border_color, rect, 1)                all_sprites.draw(window_surface)        # рисуем путь работы алгоритма        # queue , visited = ghost.logic3()        # path_head,path_segment = goal,goal        # while path_segment and path_segment in visited:        #     pygame.draw.rect(window_surface, pygame.Color('white'), get_rect(*path_segment), border_radius=TILE//3)        #     path_segment = visited[path_segment]        # pygame.draw.rect(window_surface, pygame.Color('blue'), get_rect(*start), border_radius=TILE//3)        # pygame.draw.rect(window_surface, pygame.Color('magenta'), get_rect(*path_head), border_radius=TILE//3)                if not play_game :            manager.draw_ui(window_surface)        manager.update(time_delta)        # Добовляем текст        text1 = f1.render(str(eats_count), True,                  (180, 0, 0))        window_surface.blit(text1, (550, 50))        pygame.display.update()if __name__ == '__main__':    main()