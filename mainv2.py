import pygamefrom pygame.locals import *import pygame_guifrom pygame_gui.core import ObjectIDfrom pygame_gui.elements import UIButtonimport sysimport osimport astimport randomfrom collections import dequeimport numpy as npimport inspectimport mathpygame.init()pygame.mixer.init()pygame.font.init()pygame.display.set_caption('pycMAN')window_surface = pygame.display.set_mode((800, 600))window_surface.fill((0, 0, 0, 0))clock = pygame.time.Clock()background = pygame.Surface((800, 600),pygame.SRCALPHA, 32).convert_alpha()# Музыкаpygame.mixer.music.load('data/music/bg.mp3')pygame.mixer.music.play(-1)pygame.mixer.music.set_volume(0.3)step = pygame.mixer.Sound('data/music/step.wav')cave = pygame.mixer.Sound('data/music/bg_cave.wav')cave.play(-1)coin_sound = pygame.mixer.Sound('data/music/coin.wav')coin_sound.set_volume(0.3)thing_sound = pygame.mixer.Sound('data/music/vesh.wav')box_sound = pygame.mixer.Sound('data/music/box2.wav')box_sound.set_volume(0.6)ghost_sound = pygame.mixer.Sound('data/music/ghost.wav')ghost_sound.set_volume(0.2)quake_sound = pygame.mixer.Sound('data/music/quake.wav')class SoundPlay(object):    """docstring for SoundPlay"""    def __init__(self, sound,time):        super(SoundPlay, self).__init__()        self.sound = sound        self.time = time        self.sound_time = time        self.on = True    def play(self,visible=True,sound_on=True):        if self.sound_time >= self.time and visible and self.on:            self.sound.play()            self.sound_time = 0        self.sound_time += 1sound_step = SoundPlay(step,2)sound_coin = SoundPlay(coin_sound,1)sound_thing = SoundPlay(thing_sound,1)sound_box = SoundPlay(box_sound,1)sound_ghost = SoundPlay(ghost_sound,10)#############################################clock = pygame.time.Clock()is_running = TrueBLACK = (0,0,0)RED = (255, 0, 0)YELLOW = (255, 255, 0)PURPUR = (249,5,254)GREY = (33,33,33)GREEN = (0, 252, 76)BLUE = (0, 255, 255)ORENGE = (255, 185, 81)PINKY = (255,185,255)eats_count = 0f1 = pygame.font.Font(None, 36)cols, rows = 28, 36TILE = 60margin = 0cord_map_x = 0cord_map_y = 0map_game_file = 'game_fild_3.txt'# Создаем поле игрыgame_fild_texture = [ [str(random.randint(1,2)) for r in range(28)] for r in range(36) ]game_fild = [ ['0' for r in range(28)] for r in range(36) ]shadow_map = [ [200 for r in range(29)] for r in range(37) ]thing_map = []ghosts = []class BigTexture():    def __init__(self,name,image,row,col,size = (3,4)):        self.name = name        self.image = image        self.use_x = 0        self.use_y = 0        #self.max_frame = max_frame        # self.stop = stop        #self.texture_arr = [ ['0' for r in range(3)] for c in range(4) ]        self.texture_arr = []        for r in range(size[0]):            for c in range(size[1]):                cut_rect = pygame.Rect((col*60)+(c*60), (row*60)+(r*60), 60, 60)                                #self.texture_arr[c][r] = self.image.subsurface(cut_rect)                  self.texture_arr.append(self.image.subsurface(cut_rect))        def update(self,col,row):        # cut_rect = pygame.Rect(col*60, row*60, 60, 60)        # out_image = image.subsurface(cut_rect)        #print(self.texture_arr)        #print(self.use)                # image_out = self.texture_arr[self.use_x][self.use_y]                # self.use_x += 1                # if self.use_x == 4:        #     self.use_x = 0        # self.use_y += 1        # if self.use_y == 3:        #     self.use_y = 0        image_out = self.texture_arr[self.use_x]        self.use_x += 1        if self.use_x > len(self.texture_arr)-1:            self.use_x = 0         return image_outdef Texture(image,col,row):    cut_rect = pygame.Rect(col*60, row*60, 60, 60)    out_image = image.subsurface(cut_rect)    return out_image# текстурыall_texture = pygame.image.load('assets/all.png').convert_alpha()# Воротаopen_gate = BigTexture('open_gete',all_texture,5,6)close_gate = BigTexture('close_gete',all_texture,2,6)small_gate = BigTexture('small_gate',all_texture,0,10,(2,1))# Грузим картинки# полfloor1 = Texture(all_texture,3,0)floor2 = Texture(all_texture,3,1)floor3 = Texture(all_texture,3,2)floor4 = Texture(all_texture,4,2)arrow_button = Texture(all_texture,4,0) respound = Texture(all_texture,4,1)pastoment1 = Texture(all_texture,4,6)pastoment2 = Texture(all_texture,4,7)# Золотоcoin1 = Texture(all_texture,1,5)coin2 = Texture(all_texture,2,5)coin3 = Texture(all_texture,3,5)idol = Texture(all_texture,3,6)key = Texture(all_texture,0,4)barrel = Texture(all_texture,1,3)skull = Texture(all_texture,1,6)sword = Texture(all_texture,4,3)shield = Texture(all_texture,4,4)health = Texture(all_texture,4,5)elixir = Texture(all_texture,0,5)pannier = Texture(all_texture,2,3)crash_pannier = Texture(all_texture,2,4)my_ring = Texture(all_texture,0,3)# Стеныwall_up = Texture(all_texture,1,0)wall_down = Texture(all_texture,1,2)wall_left = Texture(all_texture,2,1)wall_right = Texture(all_texture,0,1)# Углыwall_up_r = Texture(all_texture,2,0)wall_up_l = Texture(all_texture,0,0)wall_down_r = Texture(all_texture,2,2)wall_down_l = Texture(all_texture,0,2)wall_crash_l = Texture(all_texture,6,1)wall_crash_r = Texture(all_texture,5,1)wall_crash_u = Texture(all_texture,7,1)wall_crash_d = Texture(all_texture,7,0)wall_boulder = Texture(all_texture,5,0)flame_empty = Texture(all_texture,0,10)# анимированые текстуры#flame = pygame.image.load('assets/flame.png').convert_alpha()flame_anim = pygame.image.load('assets/anim/fire_animation.png').convert_alpha()flame_arr_animation = []# Призракиghost_white = pygame.image.load('assets/anim/go_ghost_white_anim.png').convert_alpha()ghost_green = pygame.image.load('assets/anim/go_ghost_green_anim.png').convert_alpha()ghost_pupur = pygame.image.load('assets/anim/go_ghost_pupur_anim.png').convert_alpha()ghost_red = pygame.image.load('assets/anim/go_ghost_red_anim.png').convert_alpha()# Интерфейсlogo_game = pygame.image.load('assets/logo.png').convert_alpha()sword_in_interface = Texture(all_texture,0,8)sword_out_interface = Texture(all_texture,0,9)shield_in_interface = Texture(all_texture,1,8)shield_out_interface = Texture(all_texture,1,9)health_in_interface = Texture(all_texture,2,8)health_out_interface = Texture(all_texture,2,9)gold_interface = Texture(all_texture,3,8)key_in_interface = Texture(all_texture,4,8)key_out_interface = Texture(all_texture,4,9)# картаmap_world = pygame.image.load('assets/map.png').convert_alpha()player_marker = pygame.image.load('assets/map_you.png').convert_alpha()ghost_marker = pygame.image.load('assets/map_ghost.png').convert_alpha()tape = BigTexture('123',all_texture,0,7,(1,3))# health = pygame.image.load('assets/health.png').convert_alpha()# health_out = pygame.image.load('assets/health_out.png').convert_alpha()# golds = pygame.image.load('assets/gold.png').convert_alpha()# Меню игрыdef menu_ui():    global manager,manager_setings,start_button,music_button,sound_button        manager = pygame_gui.UIManager((800, 600),'theme.json')    manager_setings = pygame_gui.UIManager((800, 600),'theme.json')    start_button = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((300, 425), (200, 50)),                                                 text='Зпустить игру',                                                                                              manager=manager,                                                                                              object_id=ObjectID(                                                    class_id='@friendly_buttons',                                                                                                    object_id='#start'                                                    ))    music_button = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((350, 475), (50, 50)),                                                 text='',                                                 manager=manager,                                                 object_id=ObjectID(                                                    class_id='@sound_buttons',                                                                                                    object_id='#music'                                                    ))    sound_button = pygame_gui.elements.UIButton(relative_rect=pygame.Rect((400, 475), (50, 50)),                                                 text='',                                                 manager=manager,                                                 object_id=ObjectID(                                                    class_id='@sound_buttons',                                                                                                    object_id='#sound'                                                    ))menu_ui()# Загрузка картdef load_map_game(level):    global thing_map,map_textur,map_textur_floor,game_fild    #level = 'level1'    # карта предметов    with open(level+'/game_thing_map.txt', 'r') as file:        thing_map = ast.literal_eval(file.read())    # карта текстур    with open(level+'/map_textur.txt', 'r') as file:        map_textur = ast.literal_eval(file.read())    # карта текстур пола    with open(level+'/game_floor_map.txt', 'r') as file:        map_textur_floor = ast.literal_eval(file.read())    # карта игры    with open(level+'/'+map_game_file, 'r') as file:            game_fild = ast.literal_eval(file.read())load_map_game('level1')# Систему частиц еще нужно доработатьclass Party(pygame.sprite.Sprite):    def __init__(self,life=4):      pygame.sprite.Sprite.__init__(self)      self.life = life      self.image = pygame.Surface([60, 60],pygame.SRCALPHA, 32).convert_alpha()      self.rect = self.image.get_rect()      self.rect.x = 0      self.rect.y = 0      #self.image.fill((255, 255, 255))      self.arr = []    def update(self):        self.image = pygame.Surface([60, 60],pygame.SRCALPHA, 32).convert_alpha()                for i in range(1):            porty_one = {                'x':30,                'y':40,                'speed_x':random.randint(-5,5),                'speed_y':random.randint(-5,5),                'color':255,                'life':10                }              if len(self.arr) < 100:                self.arr.append(porty_one)                    for item in self.arr:            item['x'] += item['speed_x']            item['y'] += item['speed_y']            dx = item['x'] - 30            dy = item['y'] - 60            lenght = math.sqrt(dx**2 + dy**2)                        dx/=lenght            dy/=lenght            item['speed_x'] = dx * 3            item['speed_y'] = dy * 3            dot = pygame.Rect(item['x'],item['y'],10,10)            #pygame.draw.rect(self.image, (255/(41-item['life']),0,0), dot)                        if item['life'] >= 0:                pygame.draw.circle(self.image, (255, 150, 0, 240+item['life']), (item['x'],item['y']), 1)                #pygame.draw.circle(self.image, (255,0,0), (item['x'],item['y']), 3)                item['life']-=1            else:                self.arr.remove(item)                return self.imageclass Animation():    def __init__(self,name,image,frame,max_frame,row=0,stop=False):        self.name = name        self.image = image        self.frame = frame        self.max_frame = max_frame        self.stop = stop        self.anim_arr = []        for i in range(max_frame):            cut_rect = pygame.Rect(i*60, row*60, 60, 60)            self.anim_arr.append(self.image.subsurface(cut_rect))        #print(name)    def update_anim(self):        self.frame += 1        if self.frame == self.max_frame+1 :            if not self.stop:                self.frame = 0            else:                self.frame = self.max_frame        # print(len(self.anim_arr))        # print(self.frame)        return self.anim_arr[self.frame-1]class DrawMap(pygame.sprite.Sprite):    def __init__(self):        pygame.sprite.Sprite.__init__(self)        #self.image = pygame.Surface((TILE*cols, TILE*rows))        self.image = pygame.Surface((TILE*cols, TILE*rows),pygame.SRCALPHA, 32).convert_alpha()        self.rect = self.image.get_rect()        self.rect.x = -300 #x        self.rect.y = -1660 #y        # self.rect.x = 0 #x        # self.rect.y = 0 #y        self.speed = 15        self.save_speed = 0        self.speed_x = 0        self.speed_y = 0        self.walls = []        self.key_eneble = False        self.cords = (0,0)        self.gate = 'Close'        self.quake = False        self.my_particles = Party()    def update(self,only_floor=False):        global flame_frame,textuer_floor,game_fild        self.image = pygame.Surface((TILE*cols, TILE*rows),pygame.SRCALPHA, 32).convert_alpha()        # Рисуем пакмена        #pygame.draw.circle(window_surface, RED, (400,300), 3)                # Телепорт пакмена на другую сторону карты        if self.rect.x > 370:            self.rect.x = -1250        if self.rect.x < -1250:            self.rect.x = 370        # Упровляем пакменом двигая карту        keystate = pygame.key.get_pressed()        flag = True                if self.key_eneble and play_game and not popup_window.visible :            if keystate[pygame.K_LEFT]:                self.speed_x = self.speed                self.speed_y = 0                flag = False            if keystate[pygame.K_RIGHT]:                self.speed_x = -self.speed                self.speed_y = 0                 flag = False            if keystate[pygame.K_UP]:                self.speed_x = 0                self.speed_y = self.speed                flag = False            if keystate[pygame.K_DOWN]:                self.speed_x = 0                self.speed_y = -self.speed                flag = False                    # Движение        self.rect.x += self.speed_x            self.rect.y += self.speed_y         self.walls = []        # Добовляем стены для столкновения        for row in range(len(game_fild)):            for col in range(len(game_fild[row])):                 wall = pygame.Rect(self.rect.x + col*TILE, self.rect.y + row*TILE, TILE, TILE)                self.walls.append([wall,game_fild[row][col],(row,col)])        quake_int_x = 0        quake_int_y = 0        if self.quake:            quake_int_x = random.randint(-2,2)            quake_int_y = random.randint(-2,2)                    # Отрисовываем карту        for row in range(len(game_fild)):            for col in range(len(game_fild[row])):                             rect = pygame.Rect(col*TILE, row*TILE, TILE, TILE)                # cord_x = self.rect.x + col*TILE                # cord_y = self.rect.y + row*TILE                cord_x = col*TILE+quake_int_x                cord_y = row*TILE+quake_int_y                                                cord_x_mony = self.rect.x + col*TILE                cord_y_mony = self.rect.y + row*TILE                self.cords = (self.rect.x,self.rect.y)                #rect = pygame.Rect(col*15, row*15, 5, 5)                border_color = GREY                # Пустой пол                if game_fild[row][col] == '0':                    # Рисуем пол                      #rect = pygame.Rect(col*15, row*15, 5, 5)                                   #wall = pygame.draw.rect(self.image, border_color, rect, 1)                                        #self.image.blit(floor1, (col*TILE, row*TILE))                    #window_surface.blit(floor1, (cord_x, cord_y))                    #self.image.blit(floor1, (cord_x, cord_y))                    pass                # Стены                if game_fild[row][col] == '1':                    # Рисуем пол                                        #self.image.blit(floor1, (cord_x, cord_y))                    environment_arr = []                                        # Рисуем стены                       #wall = GetEnvironment((row,col))                    wall = map_textur[row][col]                     # print(wall)                    if wall == '⌝' :                                        self.image.blit(wall_up_r, (cord_x, cord_y))                    if wall == '⌜' :                                        self.image.blit(wall_up_l, (cord_x, cord_y))                    if wall == '⌟' :                                        self.image.blit(wall_down_r, (cord_x, cord_y))                    if wall == '⌞' :                                        self.image.blit(wall_down_l, (cord_x, cord_y))                                        if wall == '-':                        self.image.blit(wall_up, (cord_x, cord_y))                    if wall == '_':                        self.image.blit(wall_down, (cord_x, cord_y))                    if wall == '⌋':                        self.image.blit(wall_right, (cord_x, cord_y))                    if wall == '⌊':                        self.image.blit(wall_left, (cord_x, cord_y))                    if wall == '>':                        self.image.blit(wall_crash_l, (cord_x, cord_y))                    if wall == '<':                        self.image.blit(wall_crash_r, (cord_x, cord_y))                    if wall == '⌃':                        self.image.blit(wall_crash_u, (cord_x, cord_y))                    if wall == '⌄':                        self.image.blit(wall_crash_d, (cord_x, cord_y))                    if wall == '◆':                        self.image.blit(wall_boulder, (cord_x, cord_y))                      if wall == None:                        self.image.blit(wall_up, (cord_x, cord_y))                                # Ворота                if map_textur[row][col] == 'v':                    if 'Open' in self.gate  :                        self.image.blit(open_gate.update(0,3), (cord_x, cord_y))                    else:                        self.image.blit(close_gate.update(0,3), (cord_x, cord_y))                if map_textur[row][col] == 'V':                    self.image.blit(small_gate.update(0,3), (cord_x, cord_y))                # Факела                if thing_map[row][col] == 'f':                                        # self.image.blit(flame_anim_arr[flame_frame], (cord_x, cord_y))                    # flame_frame += 1                    # if flame_frame == 7 :                    #     flame_frame = 0                    frame = random.randint(0,7)                    # print(frame)                    flame_out = False                    if flame_arr_animation != []:                                                for item in flame_arr_animation:                            if item.name == str(row)+''+str(col):                                flame_out = item.update_anim()                                                    if flame_out == False:                                                flame = Animation(str(row)+''+str(col),flame_anim,frame,7)                        flame_arr_animation.append(flame)                        flame_out = flame.update_anim()                                         self.image.blit(flame_out, (cord_x, cord_y))                                        self.image.blit(self.my_particles.update(), (cord_x, cord_y))                if thing_map[row][col] == 'F':                    self.image.blit(flame_empty, (cord_x, cord_y))                # Кольцо                if thing_map[row][col] == 'r':                                        self.image.blit(my_ring,(cord_x, cord_y))                                                # Тень                 shadow = shadow_map[row][col]                rect2 = pygame.Rect(0, 0, TILE, TILE)                alpha_surface = pygame.Surface((60, 60))                alpha_surface.set_alpha(shadow)  # Уровень прозрачности                pygame.draw.rect(alpha_surface, BLACK, rect2)                self.image.blit(alpha_surface, (cord_x, cord_y))                                #window_surface.blit(shadow, (cord_x, cord_y))                # bg_top = pygame.image.load('assets/floor_1.png').convert_alpha()                # self.image.blit(bg_top, (0, -35))          textuer_floor.rect.x = self.rect.x          textuer_floor.rect.y = self.rect.y                       def StopEngines(self):        self.speed_x = 0        self.speed_y = 0    def OpenGate(self):        global game_fild,popup_window        self.gate = 'Open'        game_fild[16][13] = '0'        game_fild[16][14] = '0'                popup_window.import_data(pygame.image.load('assets/history/open_dore.png').convert_alpha())        popup_window.visible = True        print('Открываем ворота')    def CenterMap(self,cord):        #print(cord[1])        speed_x = cord[0] - 370        speed_y = cord[1] - 270        if cord[0]<370:            self.speed_x = abs(speed_x)        if cord[0]>370:            self.speed_x = -abs(speed_x)        if cord[0]==370:            self.speed_x = 0        if cord[1]<270:            self.speed_y = abs(speed_y)        if cord[1]>270:            self.speed_y = -abs(speed_y)        if cord[1]==270:            self.speed_y = 0        if cord[0]==370 and cord[1]==270:            self.key_eneble = True    def GetWalls(self):        return self.wallsclass DrawFloor(pygame.sprite.Sprite):    def __init__(self):        pygame.sprite.Sprite.__init__(self)        self.image = pygame.Surface((TILE*cols, TILE*rows))        self.rect = self.image.get_rect()        self.rect.x = -360 #x        self.rect.y = -1480 #y    def update(self):        self.image = pygame.Surface((TILE*cols, TILE*rows),pygame.SRCALPHA, 32).convert_alpha()        # pygame.Surface((TILE*cols, TILE*rows),pygame.SRCALPHA, 32).convert_alpha()        # Движение        self.rect.x = level.rect.x        self.rect.y = level.rect.y        quake_int_x = 0        quake_int_y = 0        if level.quake:            quake_int_x = random.randint(-2,2)            quake_int_y = random.randint(-2,2)        # Отрисовываем карту        for row in range(len(game_fild)):            for col in range(len(game_fild[row])):                             # rect = pygame.Rect(col*TILE, row*TILE, TILE, TILE)                # cord_x = level.rect.x + col*TILE                 # cord_y = level.rect.y + row*TILE                cord_x = col*TILE+quake_int_x                cord_y = row*TILE+quake_int_y                # self.cords = (self.rect.x,self.rect.y)                # Пустой пол                if map_textur_floor[row][col] == '1':                    self.image.blit(floor1, (cord_x, cord_y))                elif map_textur_floor[row][col] == '2':                    self.image.blit(floor2, (cord_x, cord_y))                elif map_textur_floor[row][col] == '3':                    self.image.blit(floor3, (cord_x, cord_y))                else:                    self.image.blit(floor4, (cord_x, cord_y))                if map_textur_floor[row][col] == 'R':                    self.image.blit(respound, (cord_x, cord_y))                if map_textur_floor[row][col] == 'A':                    self.image.blit(arrow_button, (cord_x, cord_y))                if map_textur_floor[row][col] == 'I':                    self.image.blit(pastoment1, (cord_x, cord_y))                if map_textur_floor[row][col] == 'i':                    self.image.blit(pastoment2, (cord_x, cord_y))                # Золото                  if thing_map[row][col] == 'g':                     # Рисуем монеты                                        self.image.blit(coin1, (cord_x, cord_y))                # Идол                if thing_map[row][col] == 'i':                    self.image.blit(idol, (cord_x, cord_y))                # Ключ                if thing_map[row][col] == 'k':                    self.image.blit(key, (cord_x, cord_y))                # Меч                if thing_map[row][col] == 'w':                    self.image.blit(sword, (cord_x, cord_y))                # Щит                if thing_map[row][col] == 'W':                    self.image.blit(shield, (cord_x, cord_y))                # Здоровье                if thing_map[row][col] == 'h':                    self.image.blit(health, (cord_x, cord_y))                # Элексир                if thing_map[row][col] == 'e':                    self.image.blit(elixir, (cord_x, cord_y))                # Бочка                if thing_map[row][col] == 'b':                    self.image.blit(barrel,(cord_x, cord_y))                # Ящик                if thing_map[row][col] == 'P':                    self.image.blit(pannier,(cord_x, cord_y))                # сломанный ящик                if thing_map[row][col] == 'p':                    self.image.blit(crash_pannier,(cord_x, cord_y))                # Череп                if thing_map[row][col] == 's':                    self.image.blit(skull,(cord_x, cord_y))                #if game_fild[row][col] == '0' or game_fild[row][col] == 'e':                    # Рисуем пол                                     #wall = pygame.draw.rect(self.image, border_color, rect, 1)                                                            #window_surface.blit(floor1, (cord_x, cord_y))class Pycman(pygame.sprite.Sprite):    def __init__(self):        pygame.sprite.Sprite.__init__(self)        self.width = 60        self.height = 60        self.image = pygame.Surface((60, 60),pygame.SRCALPHA, 32).convert_alpha()        # self.skin_bottom = pygame.image.load('assets/player_bottom.png').convert_alpha()        # self.skin_top = pygame.image.load('assets/player_top.png').convert_alpha()        # self.skin_right = pygame.image.load('assets/player_right.png').convert_alpha()        # self.skin_left = pygame.image.load('assets/player_left.png').convert_alpha()        self.image.set_alpha(255)        self.skin_anim = pygame.image.load('assets/anim/go_player_anim.png').convert_alpha()        self.skin_bottom_anim = Animation('right',self.skin_anim,0,3,0)        self.skin_top_anim = Animation('right',self.skin_anim,0,3,1)        self.skin_right_anim = Animation('right',self.skin_anim,0,4,2)        self.skin_left_anim = Animation('left',self.skin_anim,0,4,3)         self.skin_bottom_anim_stop = Animation('right',self.skin_anim,0,3,4)        self.skin_top_anim_stop = Animation('right',self.skin_anim,0,3,5)        self.skin_right_anim_stop = Animation('right',self.skin_anim,0,3,6)        self.skin_left_anim_stop = Animation('left',self.skin_anim,0,3,7)                 self.activ_skin = self.skin_bottom_anim.update_anim()                self.rect = self.image.get_rect()                self.rect.x = 400 - (self.width/2) #x        self.rect.y = 300 - (self.height/2)  #y        self.cord = (0,0)        self.key_eneble = True        self.turn = 'bottom'        self.pause = False        self.invulnerability = False        self.visible = False        self.sound_on = True        self.sound_time = 2        self.ghosts = []    def update(self):        global eats_count,game_fild,thing_map                self.ghostnearby()        # Упровление персонажем        keystate = pygame.key.get_pressed()         if not self.pause:            if keystate[pygame.K_LEFT]:                self.activ_skin = self.skin_left_anim.update_anim()                self.turn = 'left'                                sound_step.play()                            if keystate[pygame.K_RIGHT]:                self.activ_skin = self.skin_right_anim.update_anim()                self.turn = 'right'                                sound_step.play()            if keystate[pygame.K_UP]:                self.activ_skin = self.skin_top_anim.update_anim()                self.turn = 'up'                sound_step.play()            if keystate[pygame.K_DOWN]:                self.activ_skin = self.skin_bottom_anim.update_anim()                self.turn = 'bottom'                sound_step.play()        if level.speed_x == 0 and level.speed_y == 0:            if self.turn == 'bottom' :                self.activ_skin = self.skin_bottom_anim_stop.update_anim()            if self.turn == 'up' :                self.activ_skin = self.skin_top_anim_stop.update_anim()            if self.turn == 'left' :                self.activ_skin = self.skin_left_anim_stop.update_anim()            if self.turn == 'right' :                self.activ_skin = self.skin_right_anim_stop.update_anim()        # Отрисовываем персонажа        self.image = pygame.Surface((60, 60),pygame.SRCALPHA, 32).convert_alpha()         self.image.blit(self.activ_skin, (0, 0))                 if self.invulnerability:            self.image.set_alpha(100)        else:            self.image.set_alpha(255)        if not self.visible:            self.image.set_alpha(0)                    # Кушаем еду на карте        cords = self.cord        #print(cords)        if thing_map[cords[0]][cords[1]] == 'g':                        thing_map[cords[0]][cords[1]] = '0'            player_interface.gold += 1            sound_coin.play()        if thing_map[cords[0]][cords[1]] == 'k' and player_interface.key == False:            player_interface.key = True            thing_map[cords[0]][cords[1]] = '0'            sound_thing.play()        if thing_map[cords[0]][cords[1]] == 'W' and player_interface.shield == False:            player_interface.shield = True            thing_map[cords[0]][cords[1]] = '0'            sound_thing.play()        if thing_map[cords[0]][cords[1]] == 'w' and player_interface.sword == False:            player_interface.sword = True            thing_map[cords[0]][cords[1]] = '0'            sound_thing.play()        if thing_map[cords[0]][cords[1]] == 'P':                        thing_map[cords[0]][cords[1]] = 'p'            sound_box.play()        if thing_map[cords[0]][cords[1]] == 'h' and player_interface.health < 3:            player_interface.health += 1            thing_map[cords[0]][cords[1]] = '0'                        sound_thing.play()                    if thing_map[cords[0]][cords[1]] == 'i':            sound_thing.play()            thing_map[cords[0]][cords[1]] = '0'            player_interface.idol = True            popup_window.import_data(pygame.image.load('assets/history/history_get_idol.png').convert_alpha())            popup_window.visible = True        #pygame.draw.circle(self.image, RED, (20,20), 20)        #floor = pygame.image.load('assets/player_bottom.png').convert_alpha()        #self.image.blit(floor, (0,0))    def sound_play(self,sound_my,time):        if self.sound_time >= time and self.visible and self.sound_on:            sound_my.play()            self.sound_time = 0        self.sound_time += 1    def reset(self):        global thing_map        self.visible = True        level.rect.x = -340        level.rect.y = -1660        player_interface.key = False        player_interface.sword = False        player_interface.shield = False        player_interface.health = 3        player_interface.gold = 0        player.invulnerability = False        load_map_game('level1')        # with open('game_thing_map.txt', 'r') as file:        #     thing_map = ast.literal_eval(file.read())    def menu_game(self):        global thing_map        level.rect.x = -170        level.rect.y = 30        player_interface.key = False        player_interface.sword = False        player_interface.shield = False        player_interface.health = 3        player_interface.gold = 0        player.invulnerability = False        self.visible = False    def ghostnearby(self):        ghosts = interface_map.map_ghost        # print(self.cord)                arr = [[[0,0] for r in range(6)] for c in range(6)]        row = [[self.cord[0],self.cord[1]+int(x-6/2)] for x in range(6)]         for r in range(6):            for c in range(len(row)):                #arr[r][c] = [self.cord[0]+int(r-6/2),self.cord[1]+int(c-6/2)]                for ghost in ghosts:                    if [ghost.cord_arr_y,ghost.cord_arr_x] == [self.cord[0]+int(r-6/2),self.cord[1]+int(c-6/2)]:                                                #ghost_sound.play()                        self.sound_play(ghost_sound,20)class Ghost(pygame.sprite.Sprite):    global game_fild    def __init__(self,name,x,y,skin,speed=3,frame=3):        pygame.sprite.Sprite.__init__(self)                self.name = name        #self.skin = pygame.image.load('assets/ghost_bottom.png').convert_alpha()        self.all_skin_map = skin        self.skin_bottom = Animation('bottom',self.all_skin_map,random.randint(0,frame),frame,0)        self.skin_top = Animation('top',self.all_skin_map,0,3,1)        self.skin_right = Animation('right',self.all_skin_map,0,3,2)        self.skin_left = Animation('left',self.all_skin_map,0,3,3)        self.skin = self.skin_bottom        self.image = pygame.Surface((60, 60),pygame.SRCALPHA, 32).convert_alpha()        self.rect = self.image.get_rect()         self.image.blit(self.skin.update_anim(), (0, 0))        self.color = GREEN                self.rest_cord = [x,y]                self.cord = [x,y]        #self.cord_logic = (self.cord[0],self.cord[1])        # определяем кординаты приведения и ставим его туда        cords = get_cord(self.cord[0],self.cord[1])        cord_x,cord_y = level.cords                self.small_cord_x = cord_x + cords[0]        self.small_cord_y = cord_y + cords[1]        self.cord_arr_x = self.cord[0]        self.cord_arr_y = self.cord[1]        self.cord_logic = (0,0)                self.rect.x = 0 #x        self.rect.y = 0 #y        self.speed = speed        self.save_speed = 0        self.speed_x = 0        self.speed_y = 0         self.choice = []        self.direction = ''        self.flag_turn = True        self.error = 0    def update(self):        global game_fild        # Определяем кординаты в массиве        my_cord = get_my_rect(self.small_cord_x-90,self.small_cord_y-90)        x = self.cord_arr_x        y = self.cord_arr_y        # Сенсоры        sensor_left = game_fild[y][x-1]        sensor_top = game_fild[y-1][x]        try: # обрабатываем ошибку отсутствия элемента массива            sensor_right = game_fild[y][x+1]            sensor_bottom = game_fild[y+1][x]        except:            print('ошибка')            sensor_right = '0'                        sensor_bottom = '0'        # print(' ',sensor_top)        # print(sensor_left,game_fild[y][x],sensor_right)        # print(' ',sensor_bottom)        # Логика        #print(game_fild[16][13])        self.cord_logic = (x,y)        self.direction = self.logic(game_fild)        if self.direction == '' and level.gate == 'Open':            self.reset()            print(self.name)        #print(self.direction)        # Управление            self.speed_x = 0        self.speed_y = 0        if self.direction == 'left' and sensor_left != '1' :                            self.speed_x = -self.speed            self.speed_y = 0            self.skin = self.skin_left        if self.direction == 'right' and sensor_right != '1':            #print("work")            self.speed_x = self.speed            self.speed_y = 0            self.skin = self.skin_right        if self.direction == 'top' and sensor_top != '1':            #print('work2')            self.speed_x = 0            self.speed_y = -self.speed            self.skin = self.skin_top        if self.direction == 'bottom' and sensor_bottom != '1':            self.speed_x = 0            self.speed_y = self.speed             self.skin = self.skin_bottom        self.image = pygame.Surface((60, 60),pygame.SRCALPHA, 32).convert_alpha()        self.rect = self.image.get_rect()        self.image.blit(self.skin.update_anim(), (0, 0))        # Движение         # запускаем движение        self.small_cord_x += self.speed_x        self.small_cord_y += self.speed_y        # ставим на карту        map_cord_x,map_cord_y = level.cords        self.rect.x = map_cord_x + self.small_cord_x        self.rect.y = map_cord_y + self.small_cord_y        #print('work')        if self.error == 3:            self.reset()            print(self.name)    def logic(self,game_fild,sensors=None):                        if player.cord != (0,0):            pacman_pos = (player.cord[1],player.cord[0])                    else:            pacman_pos = get_my_rect(player.rect.x,player.rect.y)                       #print(game_fild[16][13])        start = self.cord_logic        graph = get_graf(game_fild)                        visited = ()        queue = []                 #print(game_fild[pacman_pos[1]][pacman_pos[0]])        try:            if pacman_pos and game_fild[pacman_pos[1]][pacman_pos[0]] != '1':                goal = pacman_pos                #print(bfs(start, pacman_pos, graph))                queue, visited = bfs(start, pacman_pos, graph)                        except:            self.error +=1            print('Ошибка+')                # рисуем путь работы алгоритма        path_gost = []        path_head,path_segment = goal,goal        while path_segment and path_segment in visited:            path_segment = visited[path_segment]            path_gost.append(path_segment)                        #level.DrawBFS(queue,visited,goal,start,graph)                direction = ' '        if len(path_gost) > 1:            path_gost.pop(-1)                    path_gost.reverse()        path_gost.append(pacman_pos)        if len(path_gost) > 1:            #print(path_gost)            if path_gost[1][0]<start[0] and path_gost[1][1] == start[1]:                #print('left')                direction = 'left'            if path_gost[1][0]>start[0] and path_gost[1][1] == start[1]:                #print('right')                direction = 'right'            if path_gost[1][0] == start[0] and path_gost[1][1] < start[1]:                #print('top')                               direction = 'top'            if path_gost[1][0] == start[0] and path_gost[1][1] > start[1]:                #print('bottom')                direction = 'bottom'                return direction    def reset(self):                        print(self.rest_cord)                  # определяем кординаты приведения и ставим его туда        self.cord_arr_x = self.rest_cord[0]        self.cord_arr_y = self.rest_cord[1]        self.cord_logic = (self.rest_cord[0],self.rest_cord[1])                self.small_cord_x = TILE * self.rest_cord[0]        self.small_cord_y = TILE * self.rest_cord[1]        map_cord_x,map_cord_y = level.cords        self.rect.x = map_cord_x + self.small_cord_x        self.rect.y = map_cord_y + self.small_cord_xclass MapInterface(pygame.sprite.Sprite):    def __init__(self):        pygame.sprite.Sprite.__init__(self)        self.width = 163               self.height = 167        self.image = pygame.Surface((self.width, self.height),pygame.SRCALPHA, 32).convert_alpha()        self.rect = self.image.get_rect()        self.map_ghost = ghosts        self.rect.x = 630 #x        self.rect.y = 430  #y    def update(self):        self.image = pygame.Surface((self.width, self.height),pygame.SRCALPHA, 32).convert_alpha()        #self.image.blit(map_world, (-28,-20))        self.image.blit(map_world, (0,0))                # Отрисовываем карту        for row in range(len(game_fild)):            for col in range(len(game_fild[row])):                rect = pygame.Rect(col * 4+28, row * 4+20, 4, 4)                #pygame.draw.rect(self.image, BLACK, rect)                                if game_fild[row][col] == '1':                    #pygame.draw.rect(self.image, GREY, rect)                    pass                if player.cord[0] == row and player.cord[1] == col:                    #pygame.draw.rect(self.image, GREEN, rect)                    self.image.blit(player_marker, (col * 4+20,row * 4+10))                for ghost in self.map_ghost:                    if ghost.cord_arr_y == row and ghost.cord_arr_x == col:                        #pygame.draw.rect(self.image, PURPUR, rect)                        self.image.blit(ghost_marker, (col * 4+20,row * 4+10))class PlaerInterface(pygame.sprite.Sprite):    """Класс игрового интерфейса"""    def __init__(self):        pygame.sprite.Sprite.__init__(self)        self.width = 800        self.height = 600        self.image = pygame.Surface((self.width, self.height),pygame.SRCALPHA, 32).convert_alpha()        self.rect = self.image.get_rect()        self.rect.x = 0 #x        self.rect.y = 0 #y        self.key = False        self.sword = False        self.shield = False        self.idol = False        self.health = 3        self.gold = 0    def update(self):        self.image = pygame.Surface((self.width, self.height),pygame.SRCALPHA, 32).convert_alpha()        self.image.blit(gold_interface, (0,0))        text1 = f1.render(str(self.gold), True,(189, 123, 0,0))        self.image.blit(text1, (70, 25))        if self.sword :            self.image.blit(sword_in_interface, (0,530))        else:            self.image.blit(sword_out_interface, (0,530))                if self.shield :            self.image.blit(shield_in_interface, (40,530))        else:            self.image.blit(shield_out_interface, (40,530))        if self.key:            self.image.blit(key_in_interface, (80,530))        else:            self.image.blit(key_out_interface, (80,530))        for i in range(3):            if self.health >= i+1:                self.image.blit(health_in_interface, (650+(i*40),0))            else:                self.image.blit(health_out_interface, (650+(i*40),0))        # self.image.blit(health_in_interface, (690,0))        # self.image.blit(health_out_interface, (730,0))# для покраски фонаclass ColoredRectSprite(pygame.sprite.Sprite):    def __init__(self, x, y, width, height, color):        super().__init__()        self.image = pygame.Surface((width, height))        self.image.fill(color)        self.rect = self.image.get_rect()        self.rect.x = x        self.rect.y = y       # Всплывающее окноclass PopupWindow(pygame.sprite.Sprite):    """docstring for PopupWindow"""    def __init__(self):        pygame.sprite.Sprite.__init__(self)        # self.width = 403        # self.height = 447        self.width = 800        self.height = 600        self.image = pygame.Surface((self.width, self.height),pygame.SRCALPHA, 32).convert_alpha()        self.bg = pygame.image.load('assets/popup.png').convert_alpha()        self.rect = self.image.get_rect()        self.close_button = pygame.image.load('assets/button_close.png').convert_alpha()                self.data = pygame.image.load('assets/history/history_empty.png').convert_alpha()        self.rect.x = 0 #x        self.rect.y = 0 #y        self.visible = False        self.settings = False    def update(self):        global popup_window,pouse_game,play_game,manager_setings        self.image = pygame.Surface((self.width, self.height),pygame.SRCALPHA, 32).convert_alpha()                if self.visible:            pygame.draw.rect(self.image,(0,0,0,150),(0,0,self.width,self.height))            self.image.blit(self.bg, (200,70))            self.image.blit(self.data, (200,70))            self.image.blit(self.close_button, (350,450))             #manager_setings.draw_ui(self.image)                                if not pouse_game and self.settings == False:                flag = True                pouse_game = True                keystate = pygame.mouse.get_pressed()                if keystate[0] and self.settings == False and self.visible == True:            self.visible = False            play_game=True            pouse_game = False        # if keystate[0] and self.settings == True and self.visible == True:        #     self.visible = False    def import_data(self,image):        self.data = imagedef GetEnvironment(cord):    row,col = cord    arr =[ ['0' for r in range(3)] for r in range(3) ]        for r in range(3):        for c in range(3):                        try:                if game_fild[row+r-1][col+c-1] != '1' or game_fild[row+r-1][col+c-1] == '':                    arr[r][c] = 0                else:                    arr[r][c] = 1            except:                arr[r][c] = 0    test =[[[0,0,0],            [0,1,1],            [0,1,0]],            [[1,1,1],             [1,1,1],             [1,1,0]],            [[0,0,0],             [1,1,1],             [1,1,0]],            [[0,0,0],             [0,1,1],             [0,1,1]],            ]    for item in test:        if arr == item :            return 'left_up'    test =[[[0,0,0],            [1,1,0],            [0,1,0]],            [[0,0,0],             [1,1,1],             [0,1,1]],            [[1,1,1],             [1,1,1],             [0,1,1]],            [[1,1,0],             [1,1,0],             [0,1,0]],            [[0,0,0],             [1,1,0],             [1,1,0]],            ]    for item in test:        if arr == item :            return 'right_up'    test =[[[0,1,0],            [1,1,0],            [0,0,0]],            [[1,1,0],             [1,1,0],             [0,0,0]],            [[0,1,1],             [1,1,1],             [1,1,1]],            [[0,1,0],             [1,1,0],             [1,1,0]],            [[0,1,1],             [1,1,1],             [0,0,0]],            ]    for item in test:        if arr == item :            return 'right_down'    test =[[[0,1,0],            [0,1,1],            [0,0,0]],            [[0,1,1],             [0,1,1],             [0,0,0]],            [[1,1,0],             [1,1,1],             [1,1,1]],            [[1,1,0],             [1,1,1],             [0,0,0]],            ]    for item in test:        if arr == item :            return 'left_down'    test =[[ [0,1,0],             [0,1,0],             [0,1,0]],            [[0,1,0],             [0,1,0],             [1,1,0]],            [[0,1,0],             [0,1,0],             [0,1,1]],            [[1,1,0],             [0,1,0],             [0,1,0]],            [[0,1,1],             [0,1,0],             [0,1,0]],            [[0,1,1],             [0,1,0],             [0,1,1]],            [[1,1,0],             [0,1,0],             [1,1,0]],            [[1,1,0],             [1,1,0],             [1,1,0]],            [[0,1,1],             [0,1,1],             [0,1,1]],            [[1,1,1],             [1,1,0],             [1,1,0]],            [[1,1,1],             [0,1,1],             [0,1,1]],            [[1,1,0],             [1,1,0],             [1,1,1]],            [[0,1,1],             [0,1,1],             [1,1,1]],            ]    for item in test:        if arr == item :            return 'vertical'    test =[ [0,0,0],            [1,1,1],            [0,0,0]            ]    if arr == test:        return 'horizont'def get_my_rect(x,y):    #print((y-30)/TILE)    #print(((y-30)/TILE)-1)    return int((x-margin)/TILE)+1, int((y-margin)/TILE)+1    #return int(x/15-30)+28 , int(y/15-30)+28def get_rect(x,y):    return x * TILE + 1, y * TILE + 1, TILE - 2, TILE - 2 def get_cord(x,y):    return [x * TILE, y * TILE]def get_next_nodes(x, y):    check_next_node = lambda x,y: True if 0 <= x < cols and 0 <= y < rows and game_fild[y][x] != '1' else False    ways = [-1,0], [0,-1], [1,0], [0,1]    return [(x+dx,y+dy) for dx,dy in ways if check_next_node(x+dx,y+dy)]def bfs(start, goal, graph) :    # print(graph)    # print(start)    # print(goal)    queue = deque([start])           visited = {start: None}    while queue:                cur_node = queue.popleft()                if cur_node == goal:            break        #print('++++'+str(graph[cur_node]))        next_nodes = graph[cur_node]        #print(visited)        for next_node in next_nodes:            if next_node not in visited:                queue.append(next_node)                visited[next_node] = cur_node    # print('work')    # print(queue)     # print(visited)    return queue, visiteddef get_graf(arr):        # создаем граф из массива поля игры    graph = {}    for y,row in enumerate(arr):        for x, col in enumerate(row):                   if col == '0' or col == 'e' :                           graph[(x,y)] = graph.get((x,y),[]) + get_next_nodes(x,y)    print(graph)    return graph# Просчет светаdef GetLight(power,cord=None,arr=None,flag=False):        # Размеры массива    width, height = 36, 28    my_map = [[0 for r in range(height)] for r in range(width) ]    shadow_map_my = [[200 for r in range(height)] for r in range(width) ]    my_light_map = [[0 for r in range(height)] for r in range(width) ]    if cord != None:        light_source_x, light_source_y = cord    else:        light_source_x, light_source_y = 0,0        my_light_map[light_source_x][light_source_y] = power    # Коэффициент затухания    attenuation = 1    # Количество шагов (проходов) распространения света    num_steps = 7    # Считаем свет игрока    for step in range(num_steps):        if cord != None:            my_light_map[light_source_x][light_source_y] = power         if arr != None:            for x in range(len(arr)):                for y in range(len(arr[x])):                    if arr[x][y] == 'f':                        my_light_map[x+1][y] = power         for x in range(len(my_light_map)):            for y in range(len(my_light_map[x])):                if game_fild[x - 1][y] != '1':                    point1 = my_light_map[x - 1][y]                else:                    point1 = 0                if game_fild[x][y - 1] != '1':                    point2 = my_light_map[x][y - 1]                else:                    point2 = 0                                                   try:                    if game_fild[x + 1][y] != '1':                        point3 = my_light_map[x + 1][y]                    else:                        point3 = 0                     if game_fild[x][y + 1] != '1':                        point4 = my_light_map[x][y + 1]                    else:                        point4 = 0                 except:                    point3 = 0                     point4 = 0                # Светим туда куда смотрит игрок                 if flag:                                   if player.turn == 'up':                        point1 = 0                    if player.turn == 'bottom':                        point3 = 0                    if player.turn == 'left':                                                point2 = 0                    if player.turn == 'right':                        point4 = 0                # собираем карту и считаем свет                my_light_map[x][y] = my_light_map[x][y] + (point1 + point2 + point3 + point4)*attenuation                my_light_map[x][y] = my_light_map[x][y] / 5                my_map[x][y] = my_light_map[x][y]    # Преводим свет в теневую карту    for x in range( width ):        for y in range( height ):            try:                if my_map[x][y] != 0:                    shadow_map_my[x][y] = int(shadow_map_my[x][y] / my_map[x][y]) - 33                if shadow_map_my[x][y] < 0:                    shadow_map_my[x][y] = 0                if shadow_map_my[x][y] > 200:                    shadow_map_my[x][y] = 200            except:                pass    return shadow_map_my# События в игреdef EventGames():    for event in pygame.event.get():            if event.type == pygame.QUIT:                is_running = False            if event.type == pygame_gui.UI_BUTTON_PRESSED:                if event.ui_element == start_button:                    print('Hello World!')                    play_game=True                    flag = True                    pouse_game = False                # if event.ui_element == exit_button:                #     print('Good bay!')                #     pygame.quit()                #     sys.exit()                # if event.ui_element == save_button:                #     #print(game_fild)                #     with open('game_fild.txt', 'w') as file:                #         file.write(str(game_fild))                # if event.ui_element == load_button:                #     with open('game_fild.txt', 'r') as file:                #         game_fild = ast.literal_eval(file.read())                # if event.ui_element == load_eats:                #     for row in range(len(game_fild)):                #         for col in range(len(game_fild[row])):                 #             if game_fild[row][col] == '0':                #                 game_fild[row][col] = 'e'            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_ESCAPE:                    play_game=False                    if not pouse_game:                        flag = True                        pouse_game = True            manager.process_events(event) # Основной цыкл игры    def main():      global is_running,game_fild,player,level,cord_map_x,cord_map_y,ghosts,shadow_map,logo_game,textuer_floor,player_interface    global popup_window,pouse_game,play_game,interface_map,particles    play_game = False    stop_game = False    pouse_game = True    flag = True               all_sprites = pygame.sprite.Group()    ghost_world = pygame.sprite.Group()    floor = pygame.sprite.Group()    interface = pygame.sprite.Group()    new_floor = pygame.sprite.Group()    popup_level = pygame.sprite.Group()    # Добовляем персонажа на поле        #new_floor.add(textuer_floor)    #floor.add(textuer_floor)    #all_sprites.add(textuer_floor)       popup_window = PopupWindow()    popup_level.add(popup_window)    # Добовляем поле        textuer_floor = DrawFloor()    player = Pycman()    particles = Party()    level = DrawMap()            #floor.add(level)     #all_sprites.add(floor)        # Добовляем карту    interface_map = MapInterface()    player_interface = PlaerInterface()        interface.add(interface_map,player_interface)    player.menu_game()    # Добовляем призраков на поле    ghost = Ghost('белый',1,1,ghost_white)        ghost2 = Ghost('зеленый',18,14,ghost_green,5)        ghost3 = Ghost('фиолетовый',9,14,ghost_pupur,5)        ghost4 = Ghost('красный',13,14,ghost_red,10,9)    #all_sprites.add(ghost,ghost2,ghost3,ghost4)    ghosts = [ghost,ghost2,ghost3,ghost4]    #ghosts =[]        bg_kost = ColoredRectSprite(0, 0, 800, 600, BLACK)        all_sprites.add(bg_kost,textuer_floor,player,ghost,ghost2,ghost3,ghost4,level)    #all_sprites.add(bg_kost,textuer_floor,player,level)    # настройки для поиска пути    start = (14,15)    goal = start    queue = deque([start])    visited = {start:None}    cur_node = start    timer_invulnerability = 0    start_game = 0    in_level = 0    quake_timer = 0        while is_running:        time_delta = clock.tick(10)/500.0        window_surface.fill((0, 0, 0, 0))        # От двойного срабатывания        if popup_window.visible:            start_button.disable()            # settings_button.disable()        else:            start_button.enable()            # settings_button.enable()        if music_button.is_selected:            music_button.select()        else:            music_button.unselect()        if sound_button.is_selected:            sound_button.select()        else:            sound_button.unselect()        # Обработка событий в игре        for event in pygame.event.get():            if event.type == pygame.QUIT:                is_running = False            if event.type == pygame_gui.UI_BUTTON_START_PRESS and popup_window.visible == False:                if event.ui_element == start_button:                    print('Hello World!')                    if start_game == 0 or player_interface.health <= 0:                        player.reset()                        start_game = 1                    play_game=True                    flag = True                    pouse_game = False                # if event.ui_element == settings_button:                #     popup_window.settings = True                #     popup_window.visible = True                #     print('Hello World!')                if event.ui_element == music_button:                    if music_button.is_selected:                        music_button.unselect()                        pygame.mixer.music.play(-1)                    else:                                                music_button.select()                        pygame.mixer.music.pause()                if event.ui_element == sound_button:                    if sound_button.is_selected:                        sound_button.unselect()                        # player.sound_on = True                        cave.play(-1)                        sound_step.on = True                         sound_coin.on = True                          sound_thing.on = True                          sound_box.on = True                          sound_ghost.on = True                          quake_sound.set_volume(1)                    else:                                                sound_button.select()                        # player.sound_on = False                        cave.stop()                        sound_step.on = False                         sound_coin.on = False                          sound_thing.on = False                         sound_box.on = False                         sound_ghost.on = False                        quake_sound.set_volume(0)                # if event.ui_element == exit_button:                #     print('Good bay!')                #     pygame.quit()                #     sys.exit()                # if event.ui_element == save_button:                #     #print(game_fild)                #     with open('game_fild.txt', 'w') as file:                #         file.write(str(game_fild))                # if event.ui_element == load_button:                #     with open('game_fild.txt', 'r') as file:                #         game_fild = ast.literal_eval(file.read())                # if event.ui_element == load_eats:                #     for row in range(len(game_fild)):                #         for col in range(len(game_fild[row])):                 #             if game_fild[row][col] == '0':                #                 game_fild[row][col] = 'e'            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_ESCAPE and popup_window.visible == False:                    play_game=False                    if not pouse_game:                        flag = True                        pouse_game = True                if event.key == pygame.K_ESCAPE and popup_window.visible == True and popup_window.settings == False:                    popup_window.visible = False                    play_game=True                    flag = True                    pouse_game = False                # if event.key == pygame.K_ESCAPE and popup_window.visible == True and popup_window.settings == True:                #     popup_window.visible = False                                manager.process_events(event)                  if stop_game:            for r_ghost in ghosts:                r_ghost.reset()            stop_game = False                if pouse_game and flag:            flag = False            for ghost in ghosts:                ghost.save_speed = ghost.speed                ghost.speed = 0        if play_game and flag:            flag = False            for ghost in ghosts:                                ghost.speed = ghost.save_speed        # Проверяем кординаты всех стен        cord_map_x,cord_map_y = level.cords        walls = level.GetWalls()                if walls != [] :             #print(walls[0])                       for wall in walls:                if player.rect.colliderect(wall[0]):                    pass                    #print(wall)                                if wall[1] == '1':                                        if player.rect.colliderect(wall[0]):                        level.key_eneble = False                                        # if  map_textur[wall[2][0]][wall[2][1]] == 'v':                    #     #print(wall)                    #     # Открываем двери                    #     if player.rect.colliderect(wall[0]) and player_interface.key == False:                    #         level.key_eneble = False                        #     elif player.rect.colliderect(wall[0]) and player_interface.key == True:                    #         level.OpenGate()                if wall[1] == '0' or wall[1] == 'e':                    if player.rect.colliderect(wall[0]):                        #print('Есть контакт дороги или еды')                        # выравниваем карту                        level.CenterMap(wall[0])                        #Передаем кординаты игроку                        player.cord = wall[2]                    # передаем кординаты приведению                        for ghost in ghosts:                        if ghost.rect.colliderect(wall[0]):                            if ghost.rect.x == wall[0].x :                                ghost.cord_arr_x = wall[2][1]                                                                                        if ghost.rect.y == wall[0].y :                                                            ghost.cord_arr_y = wall[2][0]        # Сценарий игры        if player_interface.gold >= 297 and level.gate == 'Close':            # Открываем варота            level.OpenGate()            # Трясем карту            quake_timer = 30            quake_sound.play(-1)        # Если взяли идола        if player_interface.gold >= 297 and player_interface.idol and in_level != 2:            # Трясем карту            # Включаем второй уровень            load_map_game('level2')            in_level = 2            quake_timer = 300            quake_sound.play(-1)                if quake_timer == 0:            level.quake = False            quake_sound.stop()        else:            level.quake = True            quake_timer -=1        # Проверяем на пересечение приведений        for ghost in ghosts:             if player.rect.colliderect(ghost):                print('Стоп игра')                # with open(map_game_file, 'r') as file:                #         game_fild = ast.literal_eval(file.read())                if player_interface.shield and not player_interface.sword:                    player.invulnerability = True                    player_interface.shield = False                if player_interface.sword:                    ghost.reset()                    player_interface.sword = False                                if not player.invulnerability :                    player_interface.health -=1                    player.invulnerability = True                #                if player_interface.health < 0:                    print('game over')                    player.reset()                    stop_game = True                    play_game = False                    if not pouse_game:                        flag = True                        pouse_game = True        # Проверяем не уязвимость        if player.invulnerability:            timer_invulnerability +=1        if timer_invulnerability == 30:            player.invulnerability = False            timer_invulnerability = 0        # Доббовляем в интерйфейс кординаты приведений        interface_map.map_ghost = ghosts                        # Считаем свет от пакмена        shadow_map = GetLight(255,player.cord,flag=True)        # Cчитаем свет от факела thing_map        shadow_map_fier = GetLight(255,arr=thing_map)        for x in range(len(shadow_map)):            for y in range(len(shadow_map[x])):                                shadow_map[x][y] =200 - (abs(200 - shadow_map_fier[x][y]) + abs(200 - shadow_map[x][y]))                        ## Обновление Рендерим все ##        #all_sprites.update()                #ghost_world.update()        #window_surface.blit(background, (0, 0))                        # Рисуем спрайты         #new_floor.update()        # new_floor.draw(window_surface)        #floor.draw(window_surface)        #floor.draw(window_surface)        #floor.update()                # bg = pygame.Surface((800, 600),pygame.SRCALPHA, 32).convert_alpha()        # window_surface.blit(bg, (0, 0))        all_sprites.draw(window_surface)        all_sprites.update()         # Обновляем интерфейс карту итд        if not pouse_game:            interface.update()            interface.draw(window_surface)                 # Меню игры        if not play_game :            #logo_game = pygame.transform.scale(logo_game, (314, 227))            window_surface.blit(logo_game,(240,50))            manager.draw_ui(window_surface)        popup_level.update()        popup_level.draw(window_surface)         # Настройки        if popup_window.visible and popup_window.settings:            print('work')            manager_setings.draw_ui(window_surface)        manager.update(time_delta)        manager_setings.update(time_delta)        pygame.display.update()if __name__ == '__main__':    main()